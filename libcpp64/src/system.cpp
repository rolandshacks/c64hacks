#include <cstddef>
#include <cstdint>

#include "libcpp64/system.h"

#if (MOS_EMULATOR)
static uint8_t *debug_memory = nullptr;

static address_t sys::make_address(const uint16_t addr) {
    if (nullptr == debug_memory) {
        debug_memory = new uint8_t[65536];
        for (auto i = 0; i < 65536; i++) debug_memory[i] = static_cast<uint8_t>(i % 256);
    }
    return (debug_memory + addr);
}
#endif

volatile uint8_t& sys::memory(const uint16_t address) {
    #if (MOS_CPU)
        return *(reinterpret_cast<address_t>(address));
    #else
        return *make_address(address);
    #endif
}

void sys::set_bit(const uint16_t address, uint8_t bit, bool enabled) {
    auto ptr = reinterpret_cast<address_t>(address);
    auto value = (enabled) ? *ptr | (1 << bit) : *ptr & ~(1 << bit);
    *ptr = value;
}

[[nodiscard]] bool sys::get_bit(const uint16_t address, uint8_t bit) {
    auto ptr = reinterpret_cast<address_t>(address);
    return (*ptr & (1 << bit)) != 0x0;
}

using namespace sys;

bool System::kernalAndBasicDisabled{false};

void System::init() noexcept {
}

void System::disableInterrupts() noexcept {
    asm volatile("sei");
}

void System::enableInterrupts() noexcept {
    asm volatile("cli");
}

void System::readMemory(uint16_t addr) noexcept {
    asm volatile(
        "lda %0"
        ::
        "n"(addr)
    );
}

void System::disableKernalAndBasic() noexcept {
    kernalAndBasicDisabled = true;

    System::disableInterrupts();

    memory(0xdc0d) = 0x7f;              // disable timer interrupts which can be generated by the two CIA chips
    memory(0xdd0d) = 0x7f;              // kernal uses such an interrupt to flash the cursor and
                                        // scan the keyboard, so we better stop it.

    System::readMemory(0xdc0d);         // by reading this two registers we negate any pending CIA irqs.
    System::readMemory(0xdd0d);         // if we don't do this, a pending CIA irq might occur after
                                        // we finish setting up our irq. we don't want that to happen.

    memory(0xd01a) = 0x0;               // clear VIC interrupt mask bits
    memory(0xd019) = 0x0;               // clear VIC interrupt request bits

    memMap(0x5);                        // NO kernel ROM + NO basic ROM + I/O

    System::enableInterrupts();
}

void System::enableKernalAndBasic() noexcept {
    System::disableInterrupts();
    memMap(0x7);                        // kernel ROM + basic ROM + I/O
    System::enableInterrupts();
    kernalAndBasicDisabled = false;
}

void System::memMap(uint8_t bits) noexcept {
    uint8_t memFlags = memory(0x01) & 0xf8;
    memFlags |= (bits & 0x7);
    memory(0x01) = memFlags;
}

// NOLINTNEXTLINE
void System::copyCharset(uint8_t* dest, size_t src_offset, size_t count) noexcept {
    disableInterrupts();
    uint8_t oldMemFlags = memory(0x01);
    memory(0x1) = (oldMemFlags & 0xfb);  // enable access to Character ROM
                                         // instead of mem-mapped I/O at $d000

    //memcpy(dest, (const uint8_t*) (0xd000 + src_offset), count > 0 ? count : 0x1000);

    const uint8_t* src = (const uint8_t*) (0xd000 +  src_offset);

    if (0 == count) count = 0x1000; // default size
    while (count) {
        *(dest++) = *(src++);
        count--;
    }

    memory(0x01) = oldMemFlags;

    enableInterrupts();
}

[[nodiscard]] constexpr uint8_t System::get_compiler_standard() noexcept {
    if (__cplusplus == 201703L) return 17;
    if (__cplusplus == 201402L) return 14;
    if (__cplusplus == 201103L) return 11;
    return 0;
}
